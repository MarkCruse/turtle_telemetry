<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">

<head>
    <meta charset="utf-8">
    <title>Turtle Tracking</title>
    <link rel="stylesheet" href="css/styles.css">

</head>

<body>
    <div id="document" style="width: 960px" ;>
        <div id="Title">
            <h1>Tracking Turtles</h1>
            <div id="selection"></div>
            <div id="map"></div>
            <input type="range" class="slider">
            <div id="year-value"></div>
            <div class="footer">
                <!--About:-->
                Map designed by:&nbsp;&nbsp;Mark Cruse - March 2017<br/>
                <sub>Data source:&nbsp;&nbsp;<a href="http://seamap.env.duke.edu/swot' target=" _blank "">The State of the World's Sea Turtles</a>
         <!-- <br/>Last update: 3-26-2017 1330</sub> -->
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/queue-async/1.0.7/queue.min.js"></script>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <!-- </div> -->
    <script type="text/javascript">
        var div = d3.select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        var width = 920,
            height = 580;

        const zoom = d3.zoom()
            .scaleExtent([1 / 4, 9])
            .on('zoom', function() {
                d3.select('g').attr('transform', d3.event.transform)
            });

        var tooltip = d3.select('#map').append('div')
            .attr('class', 'hidden tooltip');

        var projection = d3.geoMercator()
            // .scale(1200)                        // sets the 'zoom'
            .center([50, 10]) //center on Pacific ocean
            .scale(225) // scale for Pacific
            .rotate([-180, 0]); //rotation for Pacific

        //    .translate([width / 2, height / 2]); // center the svg (0,0 is top, left)

        var geoPath = d3.geoPath()
            .projection(projection);

        var svg = d3.select("#map").append("svg")
            .attr("width", width)
            .attr("height", height)
            //   .append("g");
            .call(zoom);

        var g = svg.append("g");

        queue()
            .defer(d3.json, "data/world-110m2.json")
            .defer(d3.csv, "data/obis_seamap_20170305_200629_custom_2010-2016.csv")
            .await(makeMap); //sends error and the next item in function


        function makeMap(error, topology, csvData) {

            g.append("path")
                .datum(topojson.feature(topology, topology.objects.countries))
                .attr("d", geoPath)
                .attr("class", "topology");

            var dataYr = [], //array to hold years
                dataName = [],
                dataProvider = [],
                dataYrProvider = [],
                datum;

            csvData.forEach(function(csvData) {
                dataYr.push(csvData.year); //load year to array
                dataName.push(csvData.common_name);
                dataProvider.push(csvData.provider_name);
            });

            function onlyUnique(value, index, self) { //find only the unique values
                return self.indexOf(value) === index;
            }
            var uniqueName = dataName.filter(onlyUnique); //contains no dups(unique) of the turtle common name
            uniqueName.sort(); //sort the unique name to alphabetise
            var topOfSelection = "Select a data provider (Reset map)";
            var uniqueProvider = dataProvider.filter(onlyUnique); //contains no dups(unique) of the data providers
            uniqueProvider.sort(); //sort the unique name to alphabetise
            uniqueProvider.unshift(topOfSelection); //add to the top of the array
            var selectorOptions = uniqueProvider;
            var currentProvider = selectorOptions;

            //Set legend color and points
            var colors = ["coral", "yellow", "red", "green", "purple", "fuchsia"];
            var legend_labels = [uniqueName[5], uniqueName[4], uniqueName[3], uniqueName[2], uniqueName[1], uniqueName[0]];

            var turtle_name = d3.scale //set colors for the unique        fturtle names represented in the data
                .category20()
                .domain(legend_labels)
                .range(colors);

            // get the start year and end year range
            var min = Math.min.apply(Math, dataYr), //get the min year
                max = Math.max.apply(Math, dataYr); //get the max year

            //   radius = d3.scale.sqrt()
            //       .domain([min, max])
            //       .range([2, 30]);

            var track = g.selectAll("circle")
                .data(csvData)
                .enter()
                .append("circle")
                .attr("r", 1) // hardcoded radius

                .attr("fill", function(d) {
                    for (i = 0; i <= uniqueName.length; i++) {
                        if (d.common_name == uniqueName[i]) { // give each turtle species it's ownn color
                            //    console.log(d.common_name,i, uniqueName[i], colors[i])
                            d.color = colors[i] // add the color to objects
                            return colors[i];
                        }
                    }
                })
                .attr("cx", function(d) {
                    d.position = projection([d.lon, d.lat])
                    if (d.position) {
                        return d.position[0];
                    }
                })
                .attr("cy", function(d) {
                    if (d.position) {
                        return d.position[1];
                    }
                })
                //end plotting points to map

                .on('mousemove', function(d) {
                    tooltip.classed('hidden', false)
                        .attr('style', 'left:' + (d3.event.clientX + 20) + 'px; top:' + (d3.event.clientY - 20) + 'px')
                        .html(d.common_name + ' ' + d.date + ' ' + d.provider_name);
                    d3.select(this).attr("class", "hover"); //apply CSS class rules
                })

                .on('mouseout', function(d) {
                    tooltip.classed('hidden', true)
                        .style("opacity", 0);
                    d3.select(this).attr("class", "none");
                });
            // var output = d3.select("#year-value").text(min + "-" + max);
            var output = d3.select("#year-value").text(max);

            // updateYr(2010, 2013, currentProvider); //auto set the max slider value to this year;
            // console.log('**************** I should only appear 1 time');

            // ----------------  B E G I N    S L I D E R   S E L E C T O R -------------------

            var slide = d3.select(".slider")
                .attr("min", min)
                .attr("max", max)
                .attr("value", min)
                .attr("step", 1)
                .on("input", function() {
                    // console.log('Invoked from slider ' + currentProvider +' '+ this.value +' '+  this.value);
                    updateYr(this.value, this.value, currentProvider);
                });

            function updateYr(val1, val2, rcvProvider) {
                // console.log('Recieving info '+rcvProvider+' '+val1+' '+val2);
                currentProvider = rcvProvider;
                output.text(Number(val1)); // output the selected date to the slider text
                track.attr("display", function(d) { //display only the points with matching year
                    if (val2 > val1){
                      if (currentProvider == d.provider_name || currentProvider[0] == topOfSelection) {
                        if (d.year < val1 || d.year > val2){
                              return "none";
                          };
                      }else{
                         return "none";
                      }; //  if (currentProvider != d.provider_name) {
                                            //       // console.log(d.year+' '+d.provider_name);
                                            //     // console.log(d.provider_name + ' ' + currentProvider);
                                            //       if (d.year > val1 || d.year < val2) {
                                            //         //  console.log(d.provider_name+' Year set to: '+ val1 + ' '+d.year);
                                            //           return "none";
                                            //       };
                                            //   };
                                            //   if (currentProvider == selectorOptions) {
                                            //     // console.log('Yes equal selectorOptions');
                                            //       if (d.year < val1 || d.year > val2){    //removes points not in date range
                                            //           return "none";
                                            //       }
                                            //   };
                    }else {   // val1 = val2
                      // console.log(currentProvider);
                      if (currentProvider == d.provider_name || currentProvider[0] == topOfSelection) {
                        // if (currentProvider == d.provider_name || currentProvider == selectorOptions) {
                        // console.log('Matches ' + currentProvider+' '+d.provider_name+' '+val1+' '+val2+' '+d.provider_name+' '+d.year);
                          if (d.year != val1){
                              return "none";
                          };
                      }else{
                         return "none";
                      };
                      // if (currentProvider == selectorOptions) {
                      //   console.log('yes')
                      //     // console.log('Matches ' + currentProvider+' '+d.provider_name+' '+val1+' '+val2+' '+d.provider_name+' '+d.year);
                      //     if (d.year != val1){
                      //         return "none";
                      //     };
                      // }else{
                      //   // console.log(selectorOptions);
                      // };
                    };
                })
            } //end function update for slider

            // ----------------  B E G I N    D R O P D O W N   S E L E C T O R -------------------

            // Listen to changes of the dropdown to select the provider to visualize on the map.
            var selector = d3.select('#selection').append('select').attr('class', 'select').on('change', function() {
                    onchangeSelector(this.value);
                });
            // load the provider_name into the dropdown
            var options = selector.selectAll('option').data(currentProvider).enter().append('option').text(function(d) {
                return d;
            });

            function onchangeSelector(newSelection) {
                currentProvider = newSelection; //THIS must stay!!
                var tdataYr = [];
                track.attr("display", function(d) {
                    if (currentProvider != d.provider_name) {
                        return "none"
                    } else {
                        tdataYr.push(d.year); //load year to array
                    };
                })
                if (currentProvider == topOfSelection){
                  var currentProvider = selectorOptions;
                  // console.log('Reset invoked'+' ');
                  var min = Math.min.apply(Math, dataYr), //get the min year
                      max = Math.max.apply(Math, dataYr); //get the max year
                  // console.log(currentProvider);

                  slide.attr("min", min).attr("max", max).attr("value", min).attr("step", 1);
                  output.text(Number(min)); // output the selected date to the slider text
                  updateYr(2010, 2010, currentProvider);
                }else{
                      // get the start year and end year range for the selected provider_name
                      var min = Math.min.apply(Math, tdataYr), //get the min year
                          max = Math.max.apply(Math, tdataYr); //get the max year
                      // console.log(min + ',' + max);
                      slide.attr("min", min).attr("max", max).attr("value", min).attr("step", 1);
                      output.text(Number(min)); // output the selected date to the slider text
                      // console.log('Passing provider from inside the onchangeSelector function: ' + currentProvider + ' min: '+min+' max: '+max);
                      updateYr(min,max,currentProvider);

                  };
                // // console.log(min + ',' + max);
                // slide.attr("min", min).attr("max", max).attr("value", min).attr("step", 1);
                // output.text(Number(min)); // output the selected date to the slider text
                // // console.log('Passing provider from inside the onchangeSelector function: ' + currentProvider + ' min: '+min+' max: '+max);
                // updateYr(min,max,currentProvider);
            } //end function onchangeSelector for dropdown selection

            // ----------------  E N D    D R O P D O W N   S E L E C T O R -------------------

            // ----------------  B E G I N    L E G E N D  -------------------
            var legend = svg.selectAll("g.legend")
                .data(uniqueName)
                .enter() //create placeholders
                .append("g") //   replace placeholders with g elements
                .attr("class", "legend"); // and give each g a legend class

            var ls_w = 20, //width of legend
                ls_h = 15; //height of legend

            legend.append("rect")
                .attr("x", width - 110) //location of legend on map
                .attr("y", function(d, i) {
                    return height - (i * ls_h) - 2 * ls_h;
                })
                .attr("width", ls_w)
                .attr("height", ls_h)
                .style("fill", function(d, i) {
                    return turtle_name(d);
                })
                .style("opacity", 0.8);

            legend.append("text")
                .attr("x", width - 80) //location of legend text on map
                .attr("y", function(d, i) {
                    return height - (i * ls_h) - ls_h - 4;
                })
                .text(function(d, i) {
                    return legend_labels[i];
                });
            // ----------------  E N D   L E G E N D  -------------------

            updateYr(2010, 2010, currentProvider); //auto set the max slider value to this year;

        }; // end function makeMap
    </script>
</body>

</html>
